/**
 * Schema Fetcher
 *
 * Fetches collection schemas from the Vibe API for type generation.
 */

import type { CollectionSchema, VibePluginOptions } from './types';

interface FetchOptions {
  apiUrl: string;
  clientId: string;
  clientSecret: string;
  debug: boolean;
}

/**
 * Fetch all available collections from the Vibe API
 */
export async function fetchCollections(options: FetchOptions): Promise<string[]> {
  const { apiUrl, clientId, clientSecret, debug } = options;

  const url = `${apiUrl}/v1/collections`;

  if (debug) {
    console.log(`[vibe-plugin] Fetching collections from ${url}`);
  }

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'X-Vibe-Client-Id': clientId,
        'X-Vibe-Client-Secret': clientSecret,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch collections: ${response.status} ${response.statusText}`);
    }

    const body = await response.json();

    // Handle various response formats
    if (Array.isArray(body)) {
      return body.map((c: any) => c.name || c);
    }

    if (body.data?.collections) {
      return body.data.collections.map((c: any) => c.name || c);
    }

    if (body.collections) {
      return body.collections.map((c: any) => c.name || c);
    }

    if (debug) {
      console.log(`[vibe-plugin] Unexpected collections response format:`, body);
    }

    return [];
  } catch (error) {
    if (debug) {
      console.error(`[vibe-plugin] Error fetching collections:`, error);
    }
    throw error;
  }
}

/**
 * Fetch TypeScript type definitions for a collection
 *
 * Calls the /v1/schemas/{collection}/typescript endpoint which returns
 * pre-generated .d.ts content from the Vibe API.
 */
export async function fetchCollectionTypes(
  collection: string,
  options: FetchOptions
): Promise<string> {
  const { apiUrl, clientId, clientSecret, debug } = options;

  const url = `${apiUrl}/v1/schemas/${collection}/typescript`;

  if (debug) {
    console.log(`[vibe-plugin] Fetching types for ${collection} from ${url}`);
  }

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'X-Vibe-Client-Id': clientId,
        'X-Vibe-Client-Secret': clientSecret,
      },
    });

    if (!response.ok) {
      // If typescript endpoint doesn't exist, try to get JSON schema and convert
      if (response.status === 404) {
        return await fetchAndConvertSchema(collection, options);
      }
      throw new Error(
        `Failed to fetch types for ${collection}: ${response.status} ${response.statusText}`
      );
    }

    const contentType = response.headers.get('content-type') || '';

    // If response is plain text (.d.ts content), return directly
    if (contentType.includes('text/plain') || contentType.includes('text/typescript')) {
      return response.text();
    }

    // If JSON, extract the typescript content
    const body = await response.json();

    if (typeof body === 'string') {
      return body;
    }

    if (body.typescript) {
      return body.typescript;
    }

    if (body.data?.typescript) {
      return body.data.typescript;
    }

    throw new Error(`Unexpected response format for ${collection} types`);
  } catch (error) {
    if (debug) {
      console.error(`[vibe-plugin] Error fetching types for ${collection}:`, error);
    }
    throw error;
  }
}

/**
 * Fallback: Fetch JSON schema and convert to TypeScript
 */
async function fetchAndConvertSchema(
  collection: string,
  options: FetchOptions
): Promise<string> {
  const { apiUrl, clientId, clientSecret, debug } = options;

  const url = `${apiUrl}/v1/schemas/${collection}`;

  if (debug) {
    console.log(`[vibe-plugin] Falling back to JSON schema for ${collection}`);
  }

  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'X-Vibe-Client-Id': clientId,
      'X-Vibe-Client-Secret': clientSecret,
    },
  });

  if (!response.ok) {
    throw new Error(
      `Failed to fetch schema for ${collection}: ${response.status} ${response.statusText}`
    );
  }

  const schema = await response.json();

  return schemaToTypeScript(collection, schema);
}

/**
 * Convert a JSON schema to TypeScript interface
 */
function schemaToTypeScript(collection: string, schema: any): string {
  const interfaceName = pascalCase(collection);
  const fields = schema.fields || schema.properties || [];

  let output = `/**
 * Auto-generated types for collection: ${collection}
 * Generated by @vibe/next-plugin
 */

`;

  // Generate main interface
  output += `export interface ${interfaceName} {\n`;

  if (Array.isArray(fields)) {
    for (const field of fields) {
      const tsType = jsonTypeToTs(field.type);
      const optional = field.nullable ? '?' : '';
      const description = field.description ? `  /** ${field.description} */\n` : '';
      output += `${description}  ${field.name}${optional}: ${tsType};\n`;
    }
  } else if (typeof fields === 'object') {
    // Handle JSON Schema format
    for (const [name, def] of Object.entries(fields)) {
      const fieldDef = def as any;
      const tsType = jsonTypeToTs(fieldDef.type);
      const optional = !schema.required?.includes(name) ? '?' : '';
      const description = fieldDef.description ? `  /** ${fieldDef.description} */\n` : '';
      output += `${description}  ${name}${optional}: ${tsType};\n`;
    }
  }

  output += `}\n\n`;

  // Generate Create type (omit auto-generated fields)
  const autoFields = findAutoFields(fields);
  if (autoFields.length > 0) {
    output += `export type ${interfaceName}Create = Omit<${interfaceName}, ${autoFields.map((f) => `'${f}'`).join(' | ')}>;\n\n`;
  } else {
    output += `export type ${interfaceName}Create = ${interfaceName};\n\n`;
  }

  // Generate Update type
  output += `export type ${interfaceName}Update = Partial<${interfaceName}Create>;\n`;

  return output;
}

/**
 * Convert JSON schema type to TypeScript type
 */
function jsonTypeToTs(type: string | string[]): string {
  if (Array.isArray(type)) {
    return type.map(jsonTypeToTs).join(' | ');
  }

  switch (type?.toLowerCase()) {
    case 'string':
      return 'string';
    case 'integer':
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return 'unknown[]';
    case 'object':
      return 'Record<string, unknown>';
    case 'null':
      return 'null';
    default:
      return 'unknown';
  }
}

/**
 * Find auto-generated fields that should be omitted from Create type
 */
function findAutoFields(fields: any): string[] {
  const autoFields: string[] = [];

  if (Array.isArray(fields)) {
    for (const field of fields) {
      if (
        field['x-vibe-pk'] ||
        field['x-vibe-auto-increment'] ||
        field.name === 'created_at' ||
        field.name === 'updated_at' ||
        field.name === 'id'
      ) {
        autoFields.push(field.name);
      }
    }
  }

  return autoFields;
}

/**
 * Convert string to PascalCase
 */
function pascalCase(str: string): string {
  return str
    .split(/[_-]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}
