/**
 * Type Generator
 *
 * Generates TypeScript declaration files from Vibe collection schemas.
 */

import * as fs from 'fs';
import * as path from 'path';
import { fetchCollections, fetchCollectionTypes } from './schema-fetcher';
import type { VibePluginOptions, TypeGenerationResult } from './types';

const DEFAULT_OUTPUT_DIR = 'node_modules/.vibe/types';

interface GeneratorOptions {
  apiUrl: string;
  clientId: string;
  clientSecret: string;
  outputDir: string;
  collections?: string[];
  debug: boolean;
}

/**
 * Generate TypeScript types for all (or specified) Vibe collections
 */
export async function generateTypes(options: GeneratorOptions): Promise<TypeGenerationResult> {
  const { apiUrl, clientId, clientSecret, outputDir, collections: specifiedCollections, debug } =
    options;

  try {
    // Ensure output directory exists
    const absoluteOutputDir = path.isAbsolute(outputDir)
      ? outputDir
      : path.join(process.cwd(), outputDir);

    fs.mkdirSync(absoluteOutputDir, { recursive: true });

    // Fetch collections to generate types for
    let collections: string[];
    if (specifiedCollections && specifiedCollections.length > 0) {
      collections = specifiedCollections;
    } else {
      collections = await fetchCollections({ apiUrl, clientId, clientSecret, debug });
    }

    if (debug) {
      console.log(`[vibe-plugin] Generating types for collections: ${collections.join(', ')}`);
    }

    // Fetch and write types for each collection
    const collectionTypes: string[] = [];
    const collectionExports: string[] = [];

    for (const collection of collections) {
      try {
        const types = await fetchCollectionTypes(collection, {
          apiUrl,
          clientId,
          clientSecret,
          debug,
        });

        // Write individual collection type file
        const fileName = `${collection}.d.ts`;
        const filePath = path.join(absoluteOutputDir, fileName);
        fs.writeFileSync(filePath, types);

        if (debug) {
          console.log(`[vibe-plugin] Generated types for ${collection} -> ${filePath}`);
        }

        collectionTypes.push(types);
        collectionExports.push(`export * from './${collection}';`);
      } catch (error) {
        console.warn(`[vibe-plugin] Failed to generate types for ${collection}:`, error);
      }
    }

    // Generate index.d.ts that re-exports all types
    const indexContent = generateIndexFile(collections);
    const indexPath = path.join(absoluteOutputDir, 'index.d.ts');
    fs.writeFileSync(indexPath, indexContent);

    // Generate package.json for the types package
    const packageJson = {
      name: '@vibe/types',
      version: '0.0.0',
      types: './index.d.ts',
      private: true,
    };
    const packageJsonPath = path.join(absoluteOutputDir, 'package.json');
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));

    if (debug) {
      console.log(`[vibe-plugin] Type generation complete. ${collections.length} collections.`);
    }

    return {
      success: true,
      collections,
      outputPath: absoluteOutputDir,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`[vibe-plugin] Type generation failed:`, message);

    return {
      success: false,
      collections: [],
      outputPath: options.outputDir,
      error: message,
    };
  }
}

/**
 * Generate the main index.d.ts file that exports all collection types
 * and provides type augmentation for @vibe/client
 */
function generateIndexFile(collections: string[]): string {
  const pascalCase = (str: string) =>
    str
      .split(/[_-]/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

  let output = `/**
 * @vibe/types
 *
 * Auto-generated type definitions for Vibe collections.
 * Generated by @vibe/next-plugin
 *
 * DO NOT EDIT MANUALLY - This file is regenerated on build.
 */

`;

  // Re-export all collection types
  for (const collection of collections) {
    output += `export * from './${collection}';\n`;
  }

  output += `\n`;

  // Generate VibeCollections interface for type-safe collection access
  output += `/**
 * Mapping of collection names to their types.
 * Used by @vibe/client for type inference.
 */
export interface VibeCollections {\n`;

  for (const collection of collections) {
    const typeName = pascalCase(collection);
    output += `  ${collection}: ${typeName};\n`;
  }

  output += `}\n\n`;

  // Type augmentation for @vibe/client
  output += `/**
 * Type augmentation for @vibe/client
 * Enables type-safe collection access without explicit generics.
 */
declare module '@vibe/client' {
  import type { Collection } from '@vibe/client';

  interface VibeClient {
    collection<K extends keyof VibeCollections>(name: K): Collection<VibeCollections[K]>;
  }
}
`;

  return output;
}

/**
 * Resolve generator options from plugin options and environment
 */
export function resolveGeneratorOptions(options: VibePluginOptions): GeneratorOptions {
  const apiUrl =
    options.apiUrl ||
    process.env.VIBE_API_URL ||
    process.env.NEXT_PUBLIC_VIBE_API_URL ||
    '';

  const clientId =
    options.clientId ||
    process.env.VIBE_CLIENT_ID ||
    process.env.NEXT_PUBLIC_VIBE_CLIENT_ID ||
    '';

  const clientSecret = options.clientSecret || process.env.VIBE_CLIENT_SECRET || '';

  const outputDir = options.outputDir || DEFAULT_OUTPUT_DIR;
  const debug = options.debug ?? false;

  if (!apiUrl) {
    console.warn(
      '[vibe-plugin] VIBE_API_URL not set. Type generation will fail. Set VIBE_API_URL environment variable.'
    );
  }

  if (!clientId) {
    console.warn(
      '[vibe-plugin] VIBE_CLIENT_ID not set. Type generation may fail if authentication is required.'
    );
  }

  return {
    apiUrl: apiUrl.replace(/\/$/, ''),
    clientId,
    clientSecret,
    outputDir,
    collections: options.collections,
    debug,
  };
}
